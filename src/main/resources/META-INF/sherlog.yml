# The preferences section tunes the global preferences for Sherlog Holmes
#
# Preferences can also be adjusted from the command line using the "preferences" command.
preferences:
  # Removes the ANSI colors from the content before parsing it
  remove-ansi-colors: true
  # The charset to use for reading the inputs
  input-charset:      UTF-8
  # The charset to use for writing
  output-charset:     UTF-8
  # Enables data paging for commands that displays data
  result-paging:      true
  # Sets the number of entries shown on each page
  results-per-page:   15
  # Clears the console before changing pages
  clear-on-paging:    true

# Data models are the structure Sherlog Holmes uses to work
models:
  # all data models should have an id for reference
  java:
    # Defines how this data model will be rendered in the command line
    # Attributes should be enclosed with "{ }", with the optional features as follows:
    #
    # - '#' uses the attribute's value and its correspondent icon
    # - '@' uses just the attribute's icon (if the attribute holds a value)
    # - '|' passes the attribute's value through a String.format() call using the given arguments in the right
    format:        '{@exception}{#source}:{line} {#timestamp} {#level|%-5s} {#category} {#thread} {#message}'
    export-format: '{timestamp} {level|%-5s} [{category}] ({thread}) {message}'
    # The list of attributes for this data model
    #
    # Attributes can be of the following types:
    # - time:            a java LocalTime (accepts format configuration)
    # - datetime:        a java LocalDateTime (accepts format configuration)
    # - zoned-datetime:  a java ZonedDateTime (accepts format configuration)
    # - offset-datetime: a java OffsetDateTime (accepts format configuration)
    # - text:            a java String
    # - number:          a java Integer
    # - decimal:         a java Double
    # - flag:            a java Boolean
    # - enum:            a set of possible String values
    #
    # Attributes might have multiple values (indicated with an '[]' after the type), which can be useful in situations
    # where you need a collection of values like exceptions that are shown in a stacktrace.
    #
    # For attributes requiring configuration, it's passed with an '|' after the type, followed by the configuration
    attributes:
      # The console log often doesn't have full timestamps
      timestamp:
        - datetime | yyyy-MM-dd HH:mm:ss,SSS
        - time     | HH:mm:ss,SSS
      level:     enum | TRACE,DEBUG,FINE,INFO,WARN,WARNING,ERROR,SEVERE,FATAL
      category:  text
      thread:    text
      message:   text
      # One entry might have multiple exceptions
      exception: text[]

  k8s-audit:
    format: |
            {#timestamp} {#cluster} {#namespace}
            {#user}
            {@decision} {#verb} {#object} {#name} {#version}
    attributes:
      timestamp: offset-datetime
      cluster:   text
      decision:  enum | forbid,allow
      verb:      text
      object:    text
      namespace: text
      name:      text
      version:   text
      user:      text

# The registry will keep track of how many entries hold each value. Counted attributes that also
# have an icon assigned will appear in the prompt.
counters:
  - source
  - level
  - category
  - thread
  - exception
  - cluster
  - object
  - verb
  - decision
  - namespace
  - name
  - user
  - version

# Parsers are the next component in the chain, responsible for getting the contents
# read by a reader and converting it into a structure
#
# Currently, there are 3 different types of parsers:
# - csv: parses the lines as a CSV row
# - json: parses the lines as JSON data
# - regex: parses the lines using a regular expression with named capture groups
parsers:
  wildfly:
    # A regex parser exposes the named groups found in the pattern
    type:      regex
    model:     java
    # You can reuse patterns across the configuration by enclosing the names with '{{ }}'
    # the names enclosed must be defined in the 'patterns' section
    pattern:   '{{ timestamp }} {{ level }}\s+{{ category }} {{ thread }} {{ message }}'
    multiline: true

  quarkus:
    type:      regex
    model:     java
    pattern:   '{{ timestamp }} {{ level }}\s+{{ category }} {{ thread }} {{ message }}'
    multiline: true

  infinispan:
    type:      regex
    model:     java
    pattern:   '{{ timestamp }} {{ level }}\s+{{ thread }} {{ category }} {{ message }}'
    multiline: true

  k8s-audit:
    type:  json
    model: k8s-audit
    attributes:
      timestamp: /_source/@timestamp
      cluster:   /_source/openshift/cluster_id
      decision:  /_source/annotations/authorization.k8s.io~1decision
      verb:      /_source/verb
      object:    /_source/objectRef/resource
      namespace: /_source/objectRef/namespace
      name:      /_source/objectRef/name
      version:   /_source/objectRef/apiVersion
      user:      /_source/user/username

patterns:
  timestamp: '(?<timestamp>(\\d{2,4}-\\d{2}-\\d{2,4} )?\\d{2}:\\d{2}:\\d{2},\\d{3})'
  level:     '(?<level>\\w+)'
  category:  '\\[(?<category>[^]]+]*)]'
  thread:    '\\((?<thread>[^)]+\\)*)\\)'
  message:   '(?<message>.+)'

# After the model is populated, it's possible to run a series of steps to
# refine the data as needed. The steps are identified, so you can apply
# different steps depending on the scenario
#
# A step is defined by the given structure:
#
# when    : a filter for applying the step only for entries matching it.
#
#           If a multiline string is given, each line will represent one
#           filter and the entry must match all of them
#
#           If a filter is not defined, the step will run for all entries
#
#           The filter syntax is the same used in the UI
#
# assign  : assigns a value to a named attribute
#
#           It's possible to reference attribute values by enclosing their
#           names with '{ }'.
#
# extract : searches for a value inside an attribute and, if it's found,
#           uses it to populate another attribute
#
# map     : uses a regex to extract named capture groups and use them to
#           populate the correspondent attributes.
#
#           The operation continues as long as there are matches, so you can
#           use this step to populate attributes with multiple values
#
# replace : replaces any occurrences of a given text with another text for a
#           defined attribute
steps:
  java-analyze-messages:
    - when: level >= WARN
      map:
        from:  message
        regex: '(?<exception>\w+(\.\w+)+(Exception|Error))'

# Pipelines are the way Sherlog Holmes binds a reader with the rest of the chain.
#
# A pipeline defines which data model, parser and steps will be used to process data
# coming from a reader.
#
# If you have the same names defined for all the four components, then Sherlog Holmes
# automatically registers a pipeline with the same name. In such cases, the default
# fallback mode will be applied.
pipelines:
  infinispan:
    model:  java
    parser: infinispan
    steps: [ java-analyze-messages ]

  wildfly:
    model:  java
    parser: wildfly
    steps: [ java-analyze-messages ]

  quarkus:
    model:  java
    parser: quarkus
    steps: [ java-analyze-messages ]

# If you define an icon with a prefix of "attribute-" and an attribute name, the icon
# will be used as a graphical representation of that attribute, so you can use it for
# the output format.
#
# If the attribute is also indexed, then its icon will show up in the command prompt
# together with a counter showing how many values were indexed.
#
# Icons are from Nerd Fonts, you can see more at
# https://www.nerdfonts.com/cheat-sheet
icons:
  attribute-level:           "󰒢"
  attribute-category:        "󰓹"
  attribute-thread:          "󰓁"
  attribute-namespace:       ""
  attribute-version:         ""
  attribute-name:            "󰓹"
  attribute-user:            ""
  attribute-verb:            ""
  attribute-decision-allow:  ""
  attribute-decision-forbid: ""
  attribute-cluster:         "󰛳"
  attribute-exception:       ""

# Styles defines how the values will appear in the console.
#
# The format is foreground/background/effects, or just the foreground color.
#
# The possible effects are:
#
# b - bold
# i - italic
# u - underline
# k - blink
# c - crossedOut
styles:
  attribute-level:           yellow
  attribute-level-TRACE:     cyan
  attribute-level-DEBUG:     cyan
  attribute-level-FINE:      cyan
  attribute-level-INFO:      orange
  attribute-level-WARN:      yellow
  attribute-level-ERROR:     red//b
  attribute-level-SEVERE:    red//b
  attribute-level-FATAL:     red//b

  attribute-category:        blue
  attribute-thread:          grey
  attribute-exception:       red

  attribute-cluster:         yellow
  attribute-verb:            blue
  attribute-object:          orange
  attribute-name:            cyan
  attribute-namespace:       teal
  attribute-user:            purple
  attribute-decision-allow:  green
  attribute-decision-forbid: red
  attribute-version:         gray//i
